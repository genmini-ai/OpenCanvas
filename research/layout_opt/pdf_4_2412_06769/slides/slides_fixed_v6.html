<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Training Large Language Models to Reason in a Continuous Latent Space</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
<style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap');

        :root {
            --primary: #1a5f7a;
            --primary-light: #2d7d9a;
            --primary-dark: #124b63;
            --secondary: #57c5b6;
            --accent: #159895;
            --background: #f1f6f9;
            --text: #1e293b;
            --text-light: #64748b;
            --white: #ffffff;
            --gradient-primary: linear-gradient(135deg, var(--primary), var(--primary-dark));
            --gradient-secondary: linear-gradient(135deg, var(--secondary), var(--accent));
            --gradient-bg: linear-gradient(135deg, rgba(26, 95, 122, 0.05), rgba(21, 152, 149, 0.05));
            --shadow-sm: 0 4px 6px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 6px 12px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.1);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 20px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-fast: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--text);
            background-color: #0a1929;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        h1, h2, h3, h4, h5 {
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            line-height: 1.2;
        }

        .presentation-container {
            position: relative;
            width: 1280px;
            height: 720px;
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            border-radius: var(--radius-lg);
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--white);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            overflow: hidden;
            z-index: 1;
            padding: 40px;
            background: var(--gradient-bg), var(--white);
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            z-index: 2;
        }

        .slide-content {
            max-width: 1200px;
            max-height: 650px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
        }

        .slide-header {
            margin-bottom: 20px;
            position: relative;
        }

        .slide-title {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 10px;
            position: relative;
            display: inline-block;
        }

        .slide-title::after {
            content: "";
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 60px;
            height: 4px;
            background: var(--gradient-secondary);
            border-radius: 2px;
            transition: var(--transition);
        }

        .slide-subtitle {
            font-size: 1.5rem;
            color: var(--text-light);
            margin-bottom: 30px;
        }

        .slide-body {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .slide-footer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .slide-number {
            background: var(--primary);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: var(--gradient-secondary);
            transition: var(--transition);
        }

        .bg-pattern {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(rgba(26, 95, 122, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            z-index: 1;
            opacity: 0.5;
        }

        .bg-gradient {
            position: absolute;
            top: 0;
            right: 0;
            width: 60%;
            height: 60%;
            background: radial-gradient(circle at top right, rgba(87, 197, 182, 0.15), transparent 70%);
            z-index: 2;
        }

        .bg-gradient-2 {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 50%;
            height: 50%;
            background: radial-gradient(circle at bottom left, rgba(26, 95, 122, 0.1), transparent 70%);
            z-index: 2;
        }

        .logo {
            position: absolute;
            top: 30px;
            right: 40px;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-icon {
            width: 24px;
            height: 24px;
            background: var(--gradient-primary);
            border-radius: 6px;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            height: 100%;
        }

        .column {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .card {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: var(--radius-md);
            padding: 30px;
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
            border: 1px solid rgba(26, 95, 122, 0.1);
            height: 100%;
        }

        .card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .card-title {
            font-size: 1.5rem;
            color: var(--primary);
            margin-bottom: 15px;
        }

        .card-content {
            color: var(--text);
            font-size: 1rem;
            line-height: 1.6;
        }

        .image-container {
            border-radius: var(--radius-md);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            background: white;
            padding: 20px;
            max-width: 100%;
            margin: 0 auto;
            text-align: center;
        }

        .image-container img {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
        }

        .image-caption {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-top: 10px;
            text-align: center;
            font-style: italic;
        }

        .feature-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .feature-item {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 15px;
        }

        .feature-icon {
            width: 40px;
            height: 40px;
            background: var(--gradient-secondary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .feature-text {
            flex: 1;
        }

        .feature-title {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .feature-description {
            font-size: 0.9rem;
            color: var(--text-light);
            line-height: 1.5;
        }

        .quote {
            font-size: 1.2rem;
            font-style: italic;
            color: var(--primary);
            margin: 30px 0;
            padding-left: 20px;
            border-left: 4px solid var(--secondary);
        }

        .highlight-box {
            background: var(--gradient-primary);
            color: white;
            padding: 20px;
            border-radius: var(--radius-md);
            margin: 20px 0;
        }

        .highlight-title {
            font-size: 1.3rem;
            margin-bottom: 10px;
        }

        .highlight-content {
            font-size: 1rem;
            line-height: 1.6;
        }

        .tag {
            display: inline-block;
            padding: 5px 10px;
            background: var(--gradient-secondary);
            color: white;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: var(--radius-md);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .comparison-table th {
            background: var(--primary);
            color: white;
            padding: 15px;
            text-align: left;
        }

        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .comparison-table tr:last-child td {
            border-bottom: none;
        }

        .comparison-table tr:nth-child(even) {
            background: rgba(0,0,0,0.02);
        }

        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: var(--gradient-primary);
            color: white;
            border-radius: 30px;
            font-weight: 500;
            text-decoration: none;
            transition: var(--transition);
            border: none;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }

        .btn:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: var(--gradient-secondary);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
        }

        .btn-outline:hover {
            background: var(--primary);
            color: white;
        }

        .navigation {
            position: absolute;
            bottom: 30px;
            right: 40px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
            border: none;
            color: var(--primary);
        }

        .nav-btn:hover {
            background: var(--primary);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-btn svg {
            width: 20px;
            height: 20px;
        }

        .animate-fade-in {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards;
        }

        .animate-fade-in-delay-1 {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards 0.1s;
        }

        .animate-fade-in-delay-2 {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards 0.2s;
        }

        .animate-fade-in-delay-3 {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards 0.3s;
        }

        .animate-fade-in-delay-4 {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards 0.4s;
        }

        .animate-fade-in-delay-5 {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards 0.5s;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            background: var(--primary-light);
            color: white;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 10px;
            vertical-align: middle;
        }

        .diagram-container {
            background: linear-gradient(135deg, rgba(26, 95, 122, 0.05), rgba(21, 152, 149, 0.05));
            border-radius: var(--radius-md);
            padding: 24px;
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow-sm);
            margin: 20px auto;
            max-width: 100%;
        }

        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: var(--radius-md);
            font-family: monospace;
            line-height: 1.5;
            overflow: auto;
            max-height: 300px;
            margin: 20px 0;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .result-card {
            background: white;
            border-radius: var(--radius-md);
            padding: 20px;
            box-shadow: var(--shadow-sm);
            text-align: center;
            transition: var(--transition);
        }

        .result-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-md);
        }

        .result-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .result-label {
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .process-steps {
            display: flex;
            justify-content: space-between;
            margin: 40px 0;
            position: relative;
        }

        .process-steps::before {
            content: "";
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--secondary);
            z-index: 1;
        }

        .process-step {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 120px;
        }

        .step-number {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--gradient-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .step-text {
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text);
        }

        .method-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }

        .method-card {
            background: white;
            border-radius: var(--radius-md);
            padding: 20px;
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
            height: 100%;
        }

        .method-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-md);
        }

        .method-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .method-icon {
            width: 40px;
            height: 40px;
            background: var(--gradient-primary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            margin-right: 15px;
        }

        .method-description {
            font-size: 0.9rem;
            color: var(--text);
            line-height: 1.6;
        }

        .data-visualization {
            background: white;
            border-radius: var(--radius-md);
            padding: 20px;
            box-shadow: var(--shadow-sm);
            margin: 30px 0;
        }

        .data-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 15px;
            text-align: center;
        }

        .data-chart {
            width: 100%;
            height: 300px;
            background: #f8fafc;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            padding: 20px;
        }

        .chart-bar {
            width: 40px;
            background: var(--gradient-primary);
            border-radius: 6px 6px 0 0;
            transition: var(--transition-slow);
            position: relative;
        }

        .chart-bar-label {
            position: absolute;
            bottom: -25px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .chart-bar-value {
            position: absolute;
            top: -25px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--primary);
        }

        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 40px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .conclusion-points {
            margin: 30px 0;
        }

        .conclusion-point {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 20px;
        }

        .point-number {
            width: 30px;
            height: 30px;
            background: var(--gradient-primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            flex-shrink: 0;
        }

        .point-text {
            flex: 1;
            font-size: 1rem;
            line-height: 1.6;
        }

        .mathjax-enabled {
            overflow-x: auto;
            padding: 15px;
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow-sm);
            margin: 20px 0;
            border: 1px solid rgba(26, 95, 122, 0.1);
        }
    </style><style>
/* ========== LAYOUT FIXER V6 - CONSTRAINT-BASED LAYOUT ========== */

/* Base container setup */
.slide.constraint-layout {
    width: 1280px !important;
    height: 720px !important;
    position: relative !important;
    overflow: hidden !important;
}

/* Content area with constraints */
.slide-content[data-constraint-content] {
    position: absolute !important;
    /* Constraints will set actual values */
    top: 40px;
    left: 40px;
    right: 40px;
    bottom: 80px;
    overflow-y: auto;
    overflow-x: hidden;
}

/* Elements positioned by constraints */
[data-constraint-image],
[data-constraint-text] {
    position: absolute !important;
    /* Initial values, will be overridden by solver */
}

/* Image constraints */
[data-constraint-image] {
    max-width: 100%;
    object-fit: contain;
}

/* Text block constraints */
[data-constraint-text] {
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Constraint solver status */
.constraint-status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 5px 10px;
    background: rgba(0, 255, 0, 0.2);
    color: green;
    font-size: 12px;
    border-radius: 4px;
    z-index: 10000;
    display: none;
}

.constraint-status.active {
    display: block;
}

.constraint-status.error {
    background: rgba(255, 0, 0, 0.2);
    color: red;
}

/* Debug mode - show constraint boundaries */
.debug-constraints [data-constraint-image],
.debug-constraints [data-constraint-text] {
    border: 1px dashed rgba(255, 0, 0, 0.3);
}

/* Responsive text scaling based on constraints */
.constraint-layout h1,
.constraint-layout .slide-title {
    font-size: calc(1.5rem + 1vw);
    line-height: 1.2;
}

.constraint-layout p,
.constraint-layout li {
    font-size: calc(0.8rem + 0.3vw);
    line-height: 1.5;
}

/* ========== END V6 CONSTRAINT CSS ========== */
</style>
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']]
            },
            options: {
                processHtmlClass: 'mathjax-enabled'
            }
        };
    </script>
</head>
<body>
<div class="presentation-container">
<!-- Slide 1: Title -->
<div class="slide active constraint-layout" data-constraint-container="true" id="slide-1">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h1 class="slide-title animate-fade-in">Training Large Language Models to Reason in a Continuous Latent Space</h1>
</div>
<div class="slide-body">
<div class="two-column">
<div class="column">
<div class="card animate-fade-in-delay-1" data-constraint-text="text-0">
<h3 class="card-title">Introducing Coconut</h3>
<p class="card-content">
                                    Chain of Continuous Thought (Coconut) is a novel paradigm that enables LLMs to reason in an unrestricted latent space instead of using natural language.
                                </p>
<div class="tags" style="margin-top: 20px;">
<span class="tag">Large Language Models</span>
<span class="tag">Reasoning</span>
<span class="tag">Latent Space</span>
</div>
</div>
<div style="margin-top: 30px;">
<p class="animate-fade-in-delay-3" style="font-size: 0.9rem; color: var(--text-light);">
<strong>Authors:</strong> Shibo Hao, Sainbayar Sukhbaatar, DiJia Su, Xian Li, Zhiting Hu, Jason Weston, Yuandong Tian
                                </p>
<p class="animate-fade-in-delay-4" style="font-size: 0.9rem; color: var(--text-light); margin-top: 5px;">
<strong>Affiliations:</strong> FAIR at Meta, UC San Diego
                                </p>
<p class="animate-fade-in-delay-5" style="font-size: 0.9rem; color: var(--text-light); margin-top: 5px;">
<strong>Date:</strong> December 12, 2024
                                </p>
</div>
</div>
<div class="column animate-fade-in-delay-2">
<div class="image-container">
<img alt="Comparison of Chain of Continuous Thought with Chain-of-Thought" data-constraint-image="image-0" src="../extracted_images/docling_page2_fig1.png"/>
<p class="image-caption">Comparison of Chain of Continuous Thought (Coconut) with Chain-of-Thought (CoT)</p>
</div>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">1</div>
<div class="progress-bar" style="width: 5%;"></div>
</div>
</div>
<!-- Slide 2: Introduction -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-2">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Introduction</h2>
</div>
<div class="slide-body">
<div class="two-column">
<div class="column">
<div class="card animate-fade-in" data-constraint-text="text-0">
<h3 class="card-title">The Challenge with Language-Based Reasoning</h3>
<p class="card-content">
                                    Large language models (LLMs) are currently restricted to reason in the "language space" using methods like chain-of-thought (CoT).
                                </p>
<p class="card-content" style="margin-top: 15px;">
                                    However, language space may not always be optimal for reasoning:
                                </p>
<ul style="margin-top: 15px; margin-left: 20px;">
<li class="animate-fade-in-delay-1">Most word tokens are primarily for textual coherence</li>
<li class="animate-fade-in-delay-2">Critical reasoning tokens require complex planning</li>
<li class="animate-fade-in-delay-3">Human neuroimaging studies show language network remains inactive during reasoning tasks</li>
</ul>
</div>
</div>
<div class="column">
<div class="highlight-box animate-fade-in-delay-2">
<h3 class="highlight-title">The Coconut Approach</h3>
<p class="highlight-content">
                                    We utilize the last hidden state of the LLM as a representation of the reasoning state (termed "continuous thought"). Rather than decoding this into a word token, we feed it back to the LLM as the subsequent input embedding directly in the continuous space.
                                </p>
</div>
<div class="quote animate-fade-in-delay-3">
                                "It would be ideal for LLMs to have the freedom to reason without any language constraints, and then translate their findings into language only when necessary."
                            </div>
<div class="tags animate-fade-in-delay-4" style="margin-top: 20px;">
<span class="tag">Continuous Thought</span>
<span class="tag">Latent Reasoning</span>
<span class="tag">Breadth-First Search</span>
</div>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">2</div>
<div class="progress-bar" style="width: 10%;"></div>
</div>
</div>
<!-- Slide 3: Coconut Method Overview -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-3">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Coconut: Method Overview</h2>
</div>
<div class="slide-body">
<div class="image-container animate-fade-in">
<img alt="Comparison of Chain of Continuous Thought with Chain-of-Thought" data-constraint-image="image-0" src="../extracted_images/docling_page2_fig1.png"/>
<p class="image-caption">Figure 1: Comparison of Chain of Continuous Thought (Coconut) with Chain-of-Thought (CoT)</p>
</div>
<div class="method-comparison">
<div class="method-card animate-fade-in-delay-1">
<div class="method-title">
<div class="method-icon">CoT</div>
                                Chain-of-Thought
                            </div>
<p class="method-description">
                                In CoT, the model generates the reasoning process as a word token sequence. Each token is produced by mapping the hidden state to a probability distribution over the vocabulary, then selecting a token.
                            </p>
</div>
<div class="method-card animate-fade-in-delay-2">
<div class="method-title">
<div class="method-icon">C</div>
                                Coconut
                            </div>
<p class="method-description">
                                Coconut regards the last hidden state as a representation of the reasoning state (termed "continuous thought"), and directly uses it as the next input embedding. This allows the LLM to reason in an unrestricted latent space.
                            </p>
</div>
</div>
<div class="card animate-fade-in-delay-3" data-constraint-text="text-0">
<h3 class="card-title">Key Components</h3>
<div class="feature-list">
<div class="feature-item" data-constraint-text="text-1">
<div class="feature-icon">1</div>
<div class="feature-text">
<h4 class="feature-title">Special Tokens</h4>
<p class="feature-description">Uses <code>&lt;bot&gt;</code> and <code>&lt;eot&gt;</code> to mark the beginning and end of latent thought mode</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-2">
<div class="feature-icon">2</div>
<div class="feature-text">
<h4 class="feature-title">Mode Switching</h4>
<p class="feature-description">The model switches between "language mode" and "latent mode"</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-3">
<div class="feature-icon">3</div>
<div class="feature-text">
<h4 class="feature-title">Hidden State Reuse</h4>
<p class="feature-description">Last hidden state is used directly as the next input embedding</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-4">
<div class="feature-icon">4</div>
<div class="feature-text">
<h4 class="feature-title">Fully Differentiable</h4>
<p class="feature-description">Continuous thoughts allow end-to-end optimization</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">3</div>
<div class="progress-bar" style="width: 15%;"></div>
</div>
</div>
<!-- Slide 4: Training Procedure -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-4">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Training Procedure</h2>
</div>
<div class="slide-body">
<div class="image-container animate-fade-in">
<img alt="Training procedure of Chain of Continuous Thought" data-constraint-image="image-0" src="../extracted_images/docling_page4_fig3.png"/>
<p class="image-caption">Figure 2: Training procedure of Chain of Continuous Thought (Coconut)</p>
</div>
<div class="card animate-fade-in-delay-1" data-constraint-text="text-0">
<h3 class="card-title">Multi-Stage Training Curriculum</h3>
<p class="card-content">
                            Coconut uses a multi-stage training curriculum inspired by Deng et al. (2024) to effectively learn continuous thought reasoning:
                        </p>
<div class="process-steps animate-fade-in-delay-2">
<div class="process-step">
<div class="step-number">1</div>
<div class="step-text">Initial CoT Training</div>
</div>
<div class="process-step">
<div class="step-number">2</div>
<div class="step-text">Replace First Step</div>
</div>
<div class="process-step">
<div class="step-number">3</div>
<div class="step-text">Progressive Replacement</div>
</div>
<div class="process-step">
<div class="step-number">4</div>
<div class="step-text">Full Latent Reasoning</div>
</div>
</div>
<p class="card-content animate-fade-in-delay-3">
                            At each stage, we integrate c additional continuous thoughts (where c is a hyperparameter) and remove one language reasoning step. The cross-entropy loss is then used on the remaining tokens after continuous thoughts.
                        </p>
<div class="highlight-box animate-fade-in-delay-4">
<h3 class="highlight-title">Key Training Insight</h3>
<p class="highlight-content">
                                The objective does not encourage the continuous thought to compress the removed language thought, but rather to facilitate the prediction of future reasoning. This allows the LLM to learn more effective representations of reasoning steps compared to human language.
                            </p>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">4</div>
<div class="progress-bar" style="width: 20%;"></div>
</div>
</div>
<!-- Slide 5: Experimental Setup -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-5">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Experimental Setup</h2>
</div>
<div class="slide-body">
<div class="two-column">
<div class="column">
<div class="card animate-fade-in" data-constraint-text="text-0">
<h3 class="card-title">Reasoning Tasks</h3>
<div class="feature-item" data-constraint-text="text-1">
<div class="feature-icon">1</div>
<div class="feature-text">
<h4 class="feature-title">GSM8k</h4>
<p class="feature-description">Grade school-level math problems for exploring latent reasoning in practical applications</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-2">
<div class="feature-icon">2</div>
<div class="feature-text">
<h4 class="feature-title">ProntoQA</h4>
<p class="feature-description">5-hop logical reasoning questions with fictional concept names</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-3">
<div class="feature-icon">3</div>
<div class="feature-text">
<h4 class="feature-title">ProsQA</h4>
<p class="feature-description">New dataset requiring substantial planning and searching over a graph to find the correct reasoning chain</p>
</div>
</div>
</div>
<div class="card animate-fade-in-delay-2" data-constraint-text="text-4" style="margin-top: 20px;">
<h3 class="card-title">Model Configuration</h3>
<ul style="margin-left: 20px;">
<li>Base model: Pre-trained GPT-2</li>
<li>Learning rate: 1 × 10<sup>-4</sup></li>
<li>Batch size: 128</li>
<li>Optimizer reset between training stages</li>
<li>Math reasoning: c = 2 (two latent thoughts per reasoning step)</li>
<li>Logical reasoning: c = 1 (one latent thought per reasoning step)</li>
</ul>
</div>
</div>
<div class="column">
<div class="card animate-fade-in-delay-1" data-constraint-text="text-5">
<h3 class="card-title">Baselines &amp; Variants</h3>
<div class="feature-item" data-constraint-text="text-6">
<div class="feature-icon">A</div>
<div class="feature-text">
<h4 class="feature-title">CoT</h4>
<p class="feature-description">Complete reasoning chains with supervised finetuning</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-7">
<div class="feature-icon">B</div>
<div class="feature-text">
<h4 class="feature-title">No-CoT</h4>
<p class="feature-description">Directly generate the answer without reasoning chain</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-8">
<div class="feature-icon">C</div>
<div class="feature-text">
<h4 class="feature-title">iCoT</h4>
<p class="feature-description">Internalized CoT using a carefully designed schedule</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-9">
<div class="feature-icon">D</div>
<div class="feature-text">
<h4 class="feature-title">Pause Token</h4>
<p class="feature-description">Special <code>&lt;pause&gt;</code> tokens inserted between question and answer</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-10">
<div class="feature-icon">E</div>
<div class="feature-text">
<h4 class="feature-title">Coconut Variants</h4>
<p class="feature-description">w/o curriculum, w/o thought, pause as thought</p>
</div>
</div>
</div>
<div class="card animate-fade-in-delay-3" data-constraint-text="text-11" style="margin-top: 20px;">
<h3 class="card-title">Evaluation Metrics</h3>
<ul style="margin-left: 20px;">
<li>Accuracy: Comparing model-generated answers with ground truth</li>
<li>Efficiency: Number of newly generated tokens per question</li>
<li>Clock-time: Average inference time per test case</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">5</div>
<div class="progress-bar" style="width: 25%;"></div>
</div>
</div>
<!-- Slide 6: Results Overview -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-6">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Results Overview</h2>
</div>
<div class="slide-body">
<div class="card animate-fade-in" data-constraint-text="text-0">
<h3 class="card-title">Performance Comparison Across Tasks</h3>
<div class="comparison-table animate-fade-in-delay-1">
<table style="width: 100%;">
<thead>
<tr>
<th>Method</th>
<th>GSM8k<br/><small>Acc. (%) / # Tokens</small></th>
<th>ProntoQA<br/><small>Acc. (%) / # Tokens</small></th>
<th>ProsQA<br/><small>Acc. (%) / # Tokens</small></th>
</tr>
</thead>
<tbody>
<tr>
<td>CoT</td>
<td>42.9 ±0.2 / 25.0</td>
<td>98.8 ±0.8 / 92.5</td>
<td>77.5 ±1.9 / 49.4</td>
</tr>
<tr>
<td>No-CoT</td>
<td>16.5 ±0.5 / 2.2</td>
<td>93.8 ±0.7 / 3.0</td>
<td>76.7 ±1.0 / 8.2</td>
</tr>
<tr>
<td>iCoT</td>
<td>30.0* / 2.2</td>
<td>99.8 ±0.3 / 3.0</td>
<td>98.2 ±0.3 / 8.2</td>
</tr>
<tr>
<td>Pause Token</td>
<td>16.4 ±1.8 / 2.2</td>
<td>77.7 ±21.0 / 3.0</td>
<td>75.9 ±0.7 / 8.2</td>
</tr>
<tr style="background: rgba(21, 152, 149, 0.1);">
<td><strong>Coconut (Ours)</strong></td>
<td><strong>34.1 ±1.5 / 8.2</strong></td>
<td><strong>99.8 ±0.2 / 9.0</strong></td>
<td><strong>97.0 ±0.3 / 14.2</strong></td>
</tr>
<tr>
<td>- w/o curriculum</td>
<td>14.4 ±0.8 / 8.2</td>
<td>52.4 ±0.4 / 9.0</td>
<td>76.1 ±0.2 / 14.2</td>
</tr>
<tr>
<td>- w/o thought</td>
<td>21.6 ±0.5 / 2.3</td>
<td>99.9 ±0.1 / 3.0</td>
<td>95.5 ±1.1 / 8.2</td>
</tr>
<tr>
<td>- pause as thought</td>
<td>24.1 ±0.7 / 2.2</td>
<td>100.0 ±0.1 / 3.0</td>
<td>96.6 ±0.8 / 8.2</td>
</tr>
</tbody>
</table>
</div>
<p class="animate-fade-in-delay-2" style="margin-top: 20px; font-size: 0.9rem; color: var(--text-light);">
                            * The result is from Deng et al. (2024).
                        </p>
</div>
<div class="highlight-box animate-fade-in-delay-3">
<h3 class="highlight-title">Key Findings</h3>
<ul style="color: white; margin-left: 20px;">
<li>Continuous thoughts effectively enhance LLM reasoning across all datasets</li>
<li>Coconut outperforms CoT on ProntoQA and ProsQA, showing advantage in planning-intensive tasks</li>
<li>Multi-stage curriculum is crucial for learning effective latent reasoning</li>
<li>Coconut shows better performance than Pause Token, indicating latent space is more effective than simply adding computation time</li>
</ul>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">6</div>
<div class="progress-bar" style="width: 30%;"></div>
</div>
</div>
<!-- Slide 7: Analysis of Continuous Thoughts -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-7">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Analysis of Continuous Thoughts</h2>
</div>
<div class="slide-body">
<div class="two-column">
<div class="column">
<div class="image-container animate-fade-in">
<img alt="Accuracy on GSM8k with different number of continuous thoughts" data-constraint-image="image-0" src="../extracted_images/docling_page6_fig4.png"/>
<p class="image-caption">Figure 3: Accuracy on GSM8k with different number of continuous thoughts</p>
</div>
<div class="card animate-fade-in-delay-2" data-constraint-text="text-0">
<h3 class="card-title">"Chaining" Continuous Thoughts</h3>
<p class="card-content">
                                    As we increase the number of continuous thoughts per reasoning step (c) from 0 to 2, the model's performance steadily improves. This suggests that:
                                </p>
<ul style="margin-left: 20px; margin-top: 10px;">
<li>Latent space reasoning retains the "chaining" property of CoT</li>
<li>Method could scale to solve increasingly complex problems by chaining more latent thoughts</li>
<li>Effective depth of the transformer increases with continuous thoughts</li>
</ul>
</div>
</div>
<div class="column">
<div class="image-container animate-fade-in-delay-1">
<img alt="Case study where continuous thought is decoded into language tokens" data-constraint-image="image-1" src="../extracted_images/docling_page7_fig5.png"/>
<p class="image-caption">Figure 4: Case study where continuous thought is decoded into language tokens</p>
</div>
<div class="card animate-fade-in-delay-3" data-constraint-text="text-1">
<h3 class="card-title">Efficient Representations</h3>
<p class="card-content">
                                    Though continuous thoughts are not intended to be decoded to language tokens, we can use the language model head to interpret them:
                                </p>
<ul style="margin-left: 20px; margin-top: 10px;">
<li>Continuous thoughts can encode multiple potential next steps simultaneously</li>
<li>The first thought in the example encodes key intermediate variables ("180", "9")</li>
<li>This ability to encode multiple paths enables more advanced reasoning patterns</li>
</ul>
</div>
<div class="highlight-box animate-fade-in-delay-4">
<h3 class="highlight-title">Latent Reasoning Advantage</h3>
<p class="highlight-content">
                                    Continuous thoughts in Coconut can encode multiple potential next steps simultaneously, allowing for a reasoning process akin to breadth-first search (BFS), even though the model is not explicitly trained to operate in this manner.
                                </p>
</div>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">7</div>
<div class="progress-bar" style="width: 35%;"></div>
</div>
</div>
<!-- Slide 8: Performance on Planning-Intensive Tasks -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-8">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Performance on Planning-Intensive Tasks</h2>
</div>
<div class="slide-body">
<div class="image-container animate-fade-in">
<img alt="The accuracy of final answer and reasoning process of multiple variants of Coconut and baselines on ProsQA" data-constraint-image="image-0" src="../extracted_images/docling_page8_fig6.png"/>
<p class="image-caption">Figure 5: The accuracy of final answer (left) and reasoning process (right) of multiple variants of Coconut and baselines on ProsQA</p>
</div>
<div class="two-column" style="margin-top: 20px;">
<div class="column">
<div class="card animate-fade-in-delay-1" data-constraint-text="text-0">
<h3 class="card-title">Interpolating Between Latent and Language Reasoning</h3>
<p class="card-content">
                                    By controlling the number of latent thoughts (k) during inference, we can observe:
                                </p>
<ul style="margin-left: 20px; margin-top: 10px;">
<li>As more reasoning is done with continuous thoughts (increasing k), both final answer accuracy and correct reasoning processes improve</li>
<li>The rate of "Hallucination" and "Wrong Target" errors decreases with more latent reasoning</li>
<li>This indicates better planning ability when more reasoning happens in the latent space</li>
</ul>
</div>
</div>
<div class="column">
<div class="highlight-box animate-fade-in-delay-2">
<h3 class="highlight-title">Advantages of Latent Reasoning</h3>
<p class="highlight-content">
                                    On ProsQA, which requires strong planning ability, Coconut and its variants substantially enhance reasoning compared to CoT, indicating that latent space reasoning provides a clear advantage in tasks demanding extensive planning.
                                </p>
</div>
<div class="card animate-fade-in-delay-3" data-constraint-text="text-1">
<h3 class="card-title">Training for Better Planning</h3>
<p class="card-content">
                                    The multi-stage training method of mixing different stages improves the model's ability to plan ahead:
                                </p>
<ul style="margin-left: 20px; margin-top: 10px;">
<li>CoT's training objective focuses only on immediate next step ("shortsighted")</li>
<li>In later stages of Coconut training, hiding the first few steps allows the model to focus more on future steps</li>
<li>This is related to multi-token prediction as a pretraining objective to improve planning</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">8</div>
<div class="progress-bar" style="width: 40%;"></div>
</div>
</div>
<!-- Slide 9: Case Study - ProsQA -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-9">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Case Study: ProsQA</h2>
</div>
<div class="slide-body">
<div class="image-container animate-fade-in">
<img alt="A case study of ProsQA showing different model behaviors" data-constraint-image="image-0" src="../extracted_images/docling_page9_fig7.png"/>
<p class="image-caption">Figure 6: A case study of ProsQA. CoT hallucinates an edge, Coconut (k=1) outputs a path that ends with an irrelevant node, but Coconut (k=2) solves the problem correctly.</p>
</div>
<div class="card animate-fade-in-delay-1" data-constraint-text="text-0" style="margin-top: 20px;">
<h3 class="card-title">Comparison of Reasoning Approaches</h3>
<div class="method-comparison">
<div class="method-card animate-fade-in-delay-2">
<div class="method-title">
<div class="method-icon">CoT</div>
                                    Chain-of-Thought
                                </div>
<p class="method-description">
                                    Gets stuck in a dead end and hallucinates a non-existent edge ("Every yumpus is a rempus") to try to complete the reasoning path. This demonstrates the challenge of making hard choices upfront without planning.
                                </p>
</div>
<div class="method-card animate-fade-in-delay-3">
<div class="method-title">
<div class="method-icon">C1</div>
                                    Coconut (k=1)
                                </div>
<p class="method-description">
                                    Uses one continuous thought but still makes a mistake, leading to a path that ends with an irrelevant node ("brimbus"). Shows improvement but still insufficient planning depth.
                                </p>
</div>
<div class="method-card animate-fade-in-delay-4" style="grid-column: span 2;">
<div class="method-title">
<div class="method-icon">C2</div>
                                    Coconut (k=2)
                                </div>
<p class="method-description">
                                    Successfully solves the problem by using two continuous thoughts. Avoids making hard choices upfront, allowing the model to progressively eliminate incorrect options and achieve higher accuracy at the end of reasoning.
                                </p>
</div>
</div>
</div>
<div class="highlight-box animate-fade-in-delay-5">
<h3 class="highlight-title">Key Insight</h3>
<p class="highlight-content">
                            Latent reasoning can avoid making premature commitments to a single path. By maintaining multiple possibilities in the continuous thoughts, the model can explore alternatives and make better decisions as more information becomes available through reasoning.
                        </p>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">9</div>
<div class="progress-bar" style="width: 45%;"></div>
</div>
</div>
<!-- Slide 10: Latent Search Trees -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-10">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Interpreting the Latent Search Tree</h2>
</div>
<div class="slide-body">
<div class="two-column">
<div class="column">
<div class="image-container animate-fade-in">
<img alt="An illustration of the latent search trees" data-constraint-image="image-0" src="../extracted_images/docling_page9_fig8.png"/>
<p class="image-caption">Figure 7: Illustration of the latent search trees for the ProsQA example</p>
</div>
<div class="card animate-fade-in-delay-2" data-constraint-text="text-0">
<h3 class="card-title">Value Function Interpretation</h3>
<p class="card-content">
                                    The probability distribution over potential next concepts can be viewed as the model's implicit value function:
                                </p>
<ul style="margin-left: 20px; margin-top: 10px;">
<li>First thought: "lempus" (0.33), "zhorpus" (0.16), "grimpus" (0.32), "sterpus" (0.01)</li>
<li>Model has ruled out "sterpus" but remains uncertain about other options</li>
<li>Second thought: Model has mostly ruled out other options and focused on "rorpus"</li>
</ul>
</div>
</div>
<div class="column">
<div class="image-container animate-fade-in-delay-1">
<img alt="Analysis of parallelism in latent tree search" data-constraint-image="image-1" src="../extracted_images/docling_page10_fig10.png"/>
<p class="image-caption">Figure 8: Analysis of parallelism in latent tree search</p>
</div>
<div class="card animate-fade-in-delay-3" data-constraint-text="text-1">
<h3 class="card-title">Parallel Exploration</h3>
<p class="card-content">
                                    The analysis of top-k candidate nodes reveals:
                                </p>
<ul style="margin-left: 20px; margin-top: 10px;">
<li>First thoughts: Significant gaps between top-1, top-2, and top-3 candidates indicate broad exploration of alternatives</li>
<li>Second thoughts: Narrower gaps show transition to more focused reasoning</li>
<li>This demonstrates the model's ability to first explore broadly, then focus on promising paths</li>
</ul>
</div>
<div class="highlight-box animate-fade-in-delay-4">
<h3 class="highlight-title">Emergent BFS-like Reasoning</h3>
<p class="highlight-content">
                                    Unlike standard BFS which explores all frontier nodes uniformly, the model demonstrates the ability to prioritize promising nodes while pruning less relevant ones, creating an efficient search strategy without explicit training.
                                </p>
</div>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">10</div>
<div class="progress-bar" style="width: 50%;"></div>
</div>
</div>
<!-- Slide 11: Why Latent Space is Better for Planning -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-11">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Why is a Latent Space Better for Planning?</h2>
</div>
<div class="slide-body">
<div class="two-column">
<div class="column">
<div class="card animate-fade-in" data-constraint-text="text-0">
<h3 class="card-title">Node Height Analysis</h3>
<p class="card-content">
                                    To understand why latent reasoning helps planning, we analyze node heights in the search tree:
                                </p>
<ul style="margin-left: 20px; margin-top: 10px;">
<li>Height = shortest distance to any leaf node</li>
<li>Nodes with lower heights have limited exploratory potential</li>
<li>Nodes with higher heights require more complex evaluation</li>
</ul>
<p class="card-content" style="margin-top: 15px;">
                                    In our example, "sterpus" is a leaf node (height = 0), making it immediately identifiable as incorrect. "Grimpus" and "lempus" have height = 2, requiring more exploration to evaluate.
                                </p>
</div>
<div class="highlight-box animate-fade-in-delay-2">
<h3 class="highlight-title">Key Advantage</h3>
<p class="highlight-content">
                                    By delaying definite decisions and expanding the latent reasoning process, the model pushes its exploration closer to the search tree's terminal states, making it easier to distinguish correct nodes from incorrect ones.
                                </p>
</div>
</div>
<div class="column">
<div class="image-container animate-fade-in-delay-1">
<img alt="The correlation between prediction probability of concepts and their heights" data-constraint-image="image-0" src="../extracted_images/docling_page11_fig12.png"/>
<p class="image-caption">Figure 9: Correlation between prediction probability of concepts and their heights</p>
</div>
<div class="card animate-fade-in-delay-3" data-constraint-text="text-1">
<h3 class="card-title">Empirical Evidence</h3>
<p class="card-content">
                                    Analysis across the test set reveals:
                                </p>
<ul style="margin-left: 20px; margin-top: 10px;">
<li>For low-height nodes, the model successfully assigns lower values to incorrect nodes and higher values to correct nodes</li>
<li>As node heights increase, this distinction becomes less pronounced</li>
<li>This confirms that evaluating nodes closer to terminal states is easier</li>
<li>Latent reasoning allows the model to delay hard decisions until more information is available</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">11</div>
<div class="progress-bar" style="width: 55%;"></div>
</div>
</div>
<!-- Slide 12: Conclusion -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-12">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true">
<div class="slide-header">
<h2 class="slide-title">Conclusion</h2>
</div>
<div class="slide-body">
<div class="card animate-fade-in" data-constraint-text="text-0">
<h3 class="card-title">Summary of Contributions</h3>
<div class="conclusion-points">
<div class="conclusion-point animate-fade-in-delay-1">
<div class="point-number">1</div>
<div class="point-text">
<strong>Novel Paradigm:</strong> Introduced Coconut (Chain of Continuous Thought), enabling LLMs to reason in an unrestricted latent space instead of using natural language.
                                </div>
</div>
<div class="conclusion-point animate-fade-in-delay-2">
<div class="point-number">2</div>
<div class="point-text">
<strong>Emergent BFS-like Reasoning:</strong> Discovered that continuous thoughts can encode multiple alternative next reasoning steps, allowing the model to perform a breadth-first search rather than prematurely committing to a single deterministic path.
                                </div>
</div>
<div class="conclusion-point animate-fade-in-delay-3">
<div class="point-number">3</div>
<div class="point-text">
<strong>Improved Performance:</strong> Demonstrated that Coconut outperforms CoT in logical reasoning tasks that require substantial backtracking during planning, with fewer thinking tokens during inference.
                                </div>
</div>
<div class="conclusion-point animate-fade-in-delay-4">
<div class="point-number">4</div>
<div class="point-text">
<strong>Theoretical Understanding:</strong> Provided insights into why latent reasoning is advantageous for planning by analyzing node heights in the search tree and showing how it helps delay hard decisions until more information is available.
                                </div>
</div>
</div>
</div>
<div class="card animate-fade-in-delay-5" data-constraint-text="text-1" style="margin-top: 20px;">
<h3 class="card-title">Future Directions</h3>
<div class="feature-list">
<div class="feature-item" data-constraint-text="text-2">
<div class="feature-icon">1</div>
<div class="feature-text">
<h4 class="feature-title">Pretraining with Continuous Thoughts</h4>
<p class="feature-description">Enable models to generalize more effectively across reasoning scenarios</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-3">
<div class="feature-icon">2</div>
<div class="feature-text">
<h4 class="feature-title">Scaling to Larger Models</h4>
<p class="feature-description">Apply Coconut to state-of-the-art LLMs for more complex reasoning tasks</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-4">
<div class="feature-icon">3</div>
<div class="feature-text">
<h4 class="feature-title">Learning Without Language Supervision</h4>
<p class="feature-description">Develop methods to learn latent reasoning without relying on language reasoning chains</p>
</div>
</div>
<div class="feature-item" data-constraint-text="text-5">
<div class="feature-icon">4</div>
<div class="feature-text">
<h4 class="feature-title">Hybrid Reasoning Approaches</h4>
<p class="feature-description">Combine language and latent reasoning for optimal performance across different tasks</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">12</div>
<div class="progress-bar" style="width: 60%;"></div>
</div>
</div>
<!-- Slide 13: Thank You -->
<div class="slide constraint-layout" data-constraint-container="true" id="slide-13">
<div class="bg-pattern"></div>
<div class="bg-gradient"></div>
<div class="bg-gradient-2"></div>
<div class="slide-content" data-constraint-content="true" style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%;">
<h1 class="slide-title animate-fade-in" style="font-size: 3.5rem; text-align: center; margin-bottom: 30px;">Thank You!</h1>
<div class="card animate-fade-in-delay-1" data-constraint-text="text-0" style="max-width: 800px; text-align: center;">
<h3 class="card-title">Training Large Language Models to Reason in a Continuous Latent Space</h3>
<p class="card-content" style="margin-top: 20px;">
                        Shibo Hao, Sainbayar Sukhbaatar, DiJia Su, Xian Li, Zhiting Hu, Jason Weston, Yuandong Tian
                    </p>
<p class="card-content" style="margin-top: 10px;">
                        FAIR at Meta, UC San Diego
                    </p>
<p class="card-content" style="margin-top: 10px;">
                        December 12, 2024
                    </p>
<div class="tags" style="margin-top: 30px; justify-content: center;">
<span class="tag">Coconut</span>
<span class="tag">Continuous Thought</span>
<span class="tag">Latent Reasoning</span>
<span class="tag">LLM Planning</span>
</div>
</div>
</div>
<div class="slide-footer">
<div class="slide-number">13</div>
<div class="progress-bar" style="width: 100%;"></div>
</div>
</div>
<!-- Navigation Controls -->
<div class="navigation">
<button class="nav-btn" disabled="" id="prev-btn">
<svg fill="none" stroke="currentColor" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M15 19l-7-7 7-7" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
</button>
<button class="nav-btn" id="next-btn">
<svg fill="none" stroke="currentColor" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M9 5l7 7-7 7" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
</button>
</div>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function() {
            const slides = document.querySelectorAll('.slide');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            let currentSlide = 0;

            function showSlide(index) {
                slides.forEach(slide => {
                    slide.classList.remove('active');
                });
                
                slides[index].classList.add('active');
                
                // Update navigation buttons
                prevBtn.disabled = index === 0;
                nextBtn.disabled = index === slides.length - 1;
                
                // Update progress bar
                const progressPercentage = ((index + 1) / slides.length) * 100;
                document.querySelectorAll('.progress-bar').forEach(bar => {
                    bar.style.width = `${progressPercentage}%`;
                });
                
                currentSlide = index;
            }

            function nextSlide() {
                if (currentSlide < slides.length - 1) {
                    showSlide(currentSlide + 1);
                }
            }

            function prevSlide() {
                if (currentSlide > 0) {
                    showSlide(currentSlide - 1);
                }
            }

            // Event listeners
            prevBtn.addEventListener('click', prevSlide);
            nextBtn.addEventListener('click', nextSlide);
            
            // Keyboard navigation
            document.addEventListener('keydown', function(e) {
                if (e.key === 'ArrowRight') {
                    nextSlide();
                } else if (e.key === 'ArrowLeft') {
                    prevSlide();
                }
            });
            
            // Initialize
            showSlide(0);
        });
    </script>
<script>
// ========== LAYOUT FIXER V6 - CONSTRAINT SOLVER ==========
(function() {
    'use strict';

    console.log('Layout Fixer V6 - Constraint Solver initializing...');

    // Simple constraint solver inspired by AutoLayout/Cassowary
    class ConstraintSolver {
        constructor() {
            this.constraints = [];
            this.elements = new Map();
            this.slideWidth = 1280;
            this.slideHeight = 720;
            this.padding = 40;
            this.spacing = 20;
        }

        // Define constraint types
        defineConstraints(slide) {
            const constraints = [];

            // Get all constraint elements
            const images = slide.querySelectorAll('[data-constraint-image]');
            const textBlocks = slide.querySelectorAll('[data-constraint-text]');
            const content = slide.querySelector('[data-constraint-content]');

            // Container constraints
            constraints.push({
                type: 'container',
                element: content,
                rules: {
                    top: this.padding,
                    left: this.padding,
                    right: this.slideWidth - this.padding,
                    bottom: this.slideHeight - 80 // Leave space for footer
                }
            });

            // Calculate available space
            const availableWidth = this.slideWidth - (2 * this.padding);
            const availableHeight = this.slideHeight - this.padding - 80;

            // Image constraints - use golden ratio for aesthetics
            images.forEach((img, index) => {
                const maxImgHeight = Math.min(400, availableHeight * 0.5);
                const maxImgWidth = availableWidth * (images.length > 1 ? 0.45 : 0.8);

                constraints.push({
                    type: 'image',
                    element: img,
                    rules: {
                        maxWidth: maxImgWidth,
                        maxHeight: maxImgHeight,
                        aspectRatio: img.naturalWidth / img.naturalHeight || 1.5
                    }
                });
            });

            // Text block constraints
            let currentY = this.padding;
            const titleElement = slide.querySelector('.slide-title, h1, h2');

            if (titleElement) {
                constraints.push({
                    type: 'title',
                    element: titleElement,
                    rules: {
                        top: currentY,
                        left: this.padding,
                        width: availableWidth,
                        maxHeight: 80
                    }
                });
                currentY += 100; // Title height + spacing
            }

            // Layout strategy based on content mix
            if (images.length > 0 && textBlocks.length > 0) {
                // Mixed content - use two-column or stacked layout
                this.defineMixedLayout(constraints, images, textBlocks, availableWidth, availableHeight, currentY);
            } else if (images.length > 0) {
                // Image-only - center and scale
                this.defineImageLayout(constraints, images, availableWidth, availableHeight, currentY);
            } else {
                // Text-only - flow naturally
                this.defineTextLayout(constraints, textBlocks, availableWidth, availableHeight, currentY);
            }

            return constraints;
        }

        defineMixedLayout(constraints, images, textBlocks, width, height, startY) {
            // Two-column layout for mixed content
            const columnWidth = (width - this.spacing) / 2;

            // Images on right
            let imgY = startY;
            images.forEach((img, i) => {
                const imgConstraint = constraints.find(c => c.element === img);
                if (imgConstraint) {
                    imgConstraint.rules.left = columnWidth + this.spacing + this.padding;
                    imgConstraint.rules.top = imgY;
                    imgConstraint.rules.maxWidth = columnWidth;
                    imgY += 220; // Image height + spacing
                }
            });

            // Text on left
            let textY = startY;
            textBlocks.forEach((text, i) => {
                constraints.push({
                    type: 'text',
                    element: text,
                    rules: {
                        top: textY,
                        left: this.padding,
                        width: columnWidth,
                        maxHeight: height - textY
                    }
                });
                textY += 100; // Estimated text block height
            });
        }

        defineImageLayout(constraints, images, width, height, startY) {
            // Center images, possibly in grid
            const numImages = images.length;

            if (numImages === 1) {
                // Single image - center it
                const img = images[0];
                const imgConstraint = constraints.find(c => c.element === img);
                if (imgConstraint) {
                    imgConstraint.rules.left = (this.slideWidth - imgConstraint.rules.maxWidth) / 2;
                    imgConstraint.rules.top = startY + 50;
                }
            } else if (numImages <= 4) {
                // Grid layout for multiple images
                const cols = numImages <= 2 ? numImages : 2;
                const rows = Math.ceil(numImages / cols);
                const gridWidth = (width - this.spacing) / cols;
                const gridHeight = (height - startY) / rows;

                images.forEach((img, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const imgConstraint = constraints.find(c => c.element === img);
                    if (imgConstraint) {
                        imgConstraint.rules.left = this.padding + (col * (gridWidth + this.spacing));
                        imgConstraint.rules.top = startY + (row * gridHeight);
                        imgConstraint.rules.maxWidth = gridWidth - this.spacing;
                        imgConstraint.rules.maxHeight = gridHeight - this.spacing;
                    }
                });
            }
        }

        defineTextLayout(constraints, textBlocks, width, height, startY) {
            // Stack text blocks with appropriate spacing
            let currentY = startY;

            textBlocks.forEach((text, i) => {
                const estimatedHeight = this.estimateTextHeight(text, width);

                constraints.push({
                    type: 'text',
                    element: text,
                    rules: {
                        top: currentY,
                        left: this.padding,
                        width: width,
                        height: Math.min(estimatedHeight, height - currentY)
                    }
                });

                currentY += estimatedHeight + this.spacing;

                // If we're running out of space, reduce font size
                if (currentY > height - 50) {
                    text.style.fontSize = '0.9em';
                }
            });
        }

        estimateTextHeight(element, width) {
            // Estimate based on text length and width
            const charCount = element.textContent.length;
            const charsPerLine = width / 8; // Rough estimate
            const lines = Math.ceil(charCount / charsPerLine);
            return lines * 25; // Line height estimate
        }

        // Solve constraints and apply to elements
        solve(constraints) {
            constraints.forEach(constraint => {
                const elem = constraint.element;
                if (!elem) return;

                const rules = constraint.rules;

                switch (constraint.type) {
                    case 'container':
                        elem.style.top = rules.top + 'px';
                        elem.style.left = rules.left + 'px';
                        elem.style.width = (rules.right - rules.left) + 'px';
                        elem.style.height = (rules.bottom - rules.top) + 'px';
                        break;

                    case 'image':
                        if (rules.left !== undefined) elem.style.left = rules.left + 'px';
                        if (rules.top !== undefined) elem.style.top = rules.top + 'px';
                        if (rules.maxWidth) elem.style.maxWidth = rules.maxWidth + 'px';
                        if (rules.maxHeight) elem.style.maxHeight = rules.maxHeight + 'px';
                        elem.style.width = 'auto';
                        elem.style.height = 'auto';
                        break;

                    case 'title':
                    case 'text':
                        if (rules.top !== undefined) elem.style.top = rules.top + 'px';
                        if (rules.left !== undefined) elem.style.left = rules.left + 'px';
                        if (rules.width !== undefined) elem.style.width = rules.width + 'px';
                        if (rules.height !== undefined) elem.style.maxHeight = rules.height + 'px';
                        elem.style.overflow = 'hidden';
                        break;
                }
            });

            return true;
        }

        // Apply constraints to a slide
        applyToSlide(slide) {
            try {
                const constraints = this.defineConstraints(slide);
                const success = this.solve(constraints);

                if (success) {
                    console.log(`V6: Applied ${constraints.length} constraints to slide ${slide.id}`);
                    return true;
                }
            } catch (error) {
                console.error('V6: Constraint solver error:', error);
                return false;
            }
        }
    }

    // Initialize solver
    const solver = new ConstraintSolver();

    // Apply to all slides
    function initializeConstraints() {
        const slides = document.querySelectorAll('.slide.constraint-layout');

        slides.forEach((slide, index) => {
            // Wait for images to load
            const images = slide.querySelectorAll('img');
            let imagesToLoad = images.length;

            const applyConstraints = () => {
                solver.applyToSlide(slide);

                // Re-apply on slide activation
                if (slide.classList.contains('active')) {
                    setTimeout(() => solver.applyToSlide(slide), 100);
                }
            };

            if (imagesToLoad === 0) {
                applyConstraints();
            } else {
                images.forEach(img => {
                    if (img.complete) {
                        imagesToLoad--;
                        if (imagesToLoad === 0) applyConstraints();
                    } else {
                        img.addEventListener('load', () => {
                            imagesToLoad--;
                            if (imagesToLoad === 0) applyConstraints();
                        });
                    }
                });
            }
        });

        // Watch for slide changes
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'attributes' &&
                    mutation.attributeName === 'class' &&
                    mutation.target.classList.contains('active')) {
                    setTimeout(() => solver.applyToSlide(mutation.target), 100);
                }
            });
        });

        slides.forEach(slide => {
            observer.observe(slide, { attributes: true });
        });

        console.log('V6: Constraint solver initialized for ' + slides.length + ' slides');
    }

    // Initialize when ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => setTimeout(initializeConstraints, 200));
    } else {
        setTimeout(initializeConstraints, 200);
    }

    // Add debug mode toggle
    window.toggleConstraintDebug = function() {
        document.body.classList.toggle('debug-constraints');
        console.log('Constraint debug mode:', document.body.classList.contains('debug-constraints'));
    };

})();
// ========== END V6 CONSTRAINT SOLVER ==========
</script></body>
</html>