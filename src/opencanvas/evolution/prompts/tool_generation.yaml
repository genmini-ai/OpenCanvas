tool_code_generation_prompt: |
  Generate a complete Python implementation for this evolution tool using the proper base class.

  Specification:
  {spec_json}{learning_context}

  CRITICAL: Your tool MUST inherit from the appropriate base class:
  
  ```python
  from opencanvas.evolution.core.base_tool import HTMLProcessingTool, ContentProcessingTool, ValidationTool
  
  class YourTool(HTMLProcessingTool):  # or ContentProcessingTool, ValidationTool, etc.
      name = "YourToolName"
      stage = "post_html"  # or "post_blog", "pre_evaluation", etc.
      priority = 0
      description = "Tool description"
      
      def process(self, content, context=None):
          # Process content here
          # MUST return processed content as STRING, never None
          # NEVER add debug messages like "[TOOL ENHANCEMENT]" to content
          # NEVER return dict/list - ONLY return string
          
          processed_content = content  # Your processing logic here
          
          # Example: CORRECT return type
          return processed_content  # ✅ Returns string
          
          # Example: WRONG return types (DO NOT DO THIS)
          # return {"content": processed_content}  # ❌ dict 
          # return [processed_content]  # ❌ list
          # return None  # ❌ None
  ```

  RESOURCE CONSTRAINTS - ONLY use these available resources:
  ✅ AVAILABLE:
  - Anthropic Claude API (multimodal - text + images)
  - OpenAI GPT API (multimodal - text + images)  
  - Gemini API (multimodal - text + images)
  - Brave Search API (for getting implementation specs and domain knowledge)
  - Python standard library (re, json, math, statistics, etc.)
  - Python packages: pdfplumber, PIL, base64 (for PDF/image processing)
  - Text processing, regex, string operations
  - Local file operations
  - Built-in data structures
  - Image processing (via multimodal LLMs)

  ❌ FORBIDDEN - Do NOT use:
  - External APIs requiring signup/billing/account creation
  - Services not already configured in Config class
  - Database services needing separate setup
  - Third-party services requiring authentication beyond existing APIs

  FEW-SHOT EXAMPLES:

  Example 1: Content Enhancement Tool
  ```python
  import logging
  import re
  from anthropic import Anthropic
  from opencanvas.config import Config
  from opencanvas.evolution.core.base_tool import ContentProcessingTool

  class ContentEnhancementTool(ContentProcessingTool):
      """Enhances HTML content with better formatting"""
      
      def __init__(self):
          super().__init__()
          self.client = Anthropic(api_key=Config.ANTHROPIC_API_KEY)
          self.logger = logging.getLogger(__name__)
      
      def process(self, content: str) -> str:
          """Process and enhance HTML content - MUST return string"""
          try:
              # Example: Add emphasis to key terms
              enhanced_content = content
              
              # Find and enhance key terms (example processing)
              key_terms = ['AI', 'machine learning', 'neural network']
              for term in key_terms:
                  pattern = r'\b' + re.escape(term) + r'\b'
                  replacement = f'<strong>{term}</strong>'
                  enhanced_content = re.sub(pattern, replacement, enhanced_content, flags=re.IGNORECASE)
              
              # CRITICAL: Always return the processed content as a STRING
              return enhanced_content
              
          except Exception as e:
              self.logger.error(f"Content enhancement failed: {{e}}")
              # CRITICAL: Return original content on error (still a string)
              return content
      
      def _generate_caption(self, image_data: str) -> str:
          """Generate caption for image using Claude VLM"""
          try:
              response = self.client.messages.create(
                  model="claude-3-7-sonnet-20250219",
                  max_tokens=200,
                  messages=[{{
                      "role": "user",
                      "content": [
                          {{"type": "image", "source": {{"type": "base64", "data": image_data}}}},
                          {{"type": "text", "text": "Generate a descriptive caption for this image from an academic paper."}}
                      ]
                  }}]
              )
              return response.content[0].text
          except Exception as e:
              self.logger.error(f"Caption generation failed: {{e}}")
              return "Caption generation failed"
  ```

  Example 2: Citation Enhancer Tool  
  ```python
  import re
  import logging
  from typing import List

  class CitationEnhancer(BaseTool):
      """Enhances citation formatting in HTML content"""
      
      PATTERNS = {{
          'apa': r'([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*\((\d{{4}})\)',
          'doi': r'doi:\s*(10\.\d{{4,}}/[-._;()/:\w]+)'
      }}
      
      def process(self, content: str) -> str:
          """Enhance citations in HTML content - MUST return string"""
          try:
              enhanced_content = content
              
              # Find APA citations and make them more prominent
              for match in re.finditer(self.PATTERNS['apa'], enhanced_content):
                  original = match.group(0)
                  author = match.group(1)
                  year = match.group(2)
                  # Create enhanced citation with semantic markup
                  enhanced = f'<cite class="citation">{author} ({year})</cite>'
                  enhanced_content = enhanced_content.replace(original, enhanced, 1)
              
              # Find DOIs and make them clickable
              for match in re.finditer(self.PATTERNS['doi'], enhanced_content):
                  doi = match.group(0)
                  doi_id = match.group(1)
                  link = f'<a href="https://doi.org/{doi_id}" class="doi-link">{doi}</a>'
                  enhanced_content = enhanced_content.replace(doi, link, 1)
              
              # CRITICAL: Always return the processed content as a STRING
              return enhanced_content
              
          except Exception as e:
              self.logger.error(f"Citation enhancement failed: {{e}}")
              # CRITICAL: Return original content on error (still a string)
              return content
      
      def _validate_citation(self, citation: str) -> bool:
          # Helper method - not called from process()
          return bool(re.match(self.PATTERNS['apa'], citation))
  ```

  Requirements:
  1. MUST inherit from appropriate base class (HTMLProcessingTool, ContentProcessingTool, or ValidationTool)
  2. MUST set class attributes: name, stage, priority, description
  3. MUST implement process(self, content, context=None) method
  4. CRITICAL: process() method MUST return a STRING (HTML/text content)
  5. NEVER return dict, list, tuple, or any other type from process()
  6. MUST return processed content (NEVER None, NEVER add debug messages)
  7. Include comprehensive error handling - return original content on error
  8. Add logging using logger = logging.getLogger(__name__)
  9. Include docstrings
  10. Use existing Config class for API keys when needed

  CRITICAL OUTPUT RULES:
  9. NEVER add status messages to content like "[TOOL ENHANCEMENT: ...]"
  10. NEVER add debug output like "validated by", "processed by", etc.
  11. NEVER modify content to include tool metadata
  12. ALWAYS return clean, production-ready content
  13. ValidationTool should NOT modify content, only validate it

  CRITICAL CODE FORMATTING RULES:
  14. NEVER use nested f-strings or complex f-string expressions
  15. For multi-line strings with variables, use .format() or % formatting instead of f-strings
  16. For LLM API calls with dynamic content, build strings separately before passing to API
  12. Example of GOOD formatting:
     ```python
     prompt_template = "Analyze this content: {{content}}"
     prompt = prompt_template.format(content=user_input)
     ```
  13. Example of BAD formatting (AVOID):
     ```python
     # DON'T DO THIS - will cause f-string nesting errors
     prompt = f"""Complex {{f"nested {{variable}}"}} string"""
     ```
  14. Use YAML for any configuration data that tools might generate, NOT JSON in f-strings
  15. If you need complex string building, use string concatenation or template libraries

  Generate ONLY the Python code, no explanations.

tool_specification_enhancement_prompt: |
  Given this tool specification, provide detailed implementation requirements:

  Tool: {tool_name}
  Purpose: {tool_purpose}
  Weakness addressed: {target_problem}

  {domain_context}

  RESOURCE CONSTRAINTS - Tool must ONLY use:
  ✅ Available: Claude/GPT/Gemini APIs (multimodal), Brave Search, Python stdlib, text/image processing
  ❌ Forbidden: External APIs requiring signup/billing, services needing separate authentication

  Provide a detailed specification including:
  1. Class name and inheritance (should inherit from HTMLProcessingTool, ContentProcessingTool, or ValidationTool)
  2. Required methods (at minimum: __init__ and process)
  3. Input/output types
  4. Algorithm approach using ONLY available resources
  5. Error handling requirements
  6. Performance requirements
  7. Integration point in pipeline
  8. Resource dependencies (from available list only)
  9. String formatting approach (avoid f-string nesting, use .format() for complex strings)

  IMPORTANT: If the tool will generate LLM prompts or complex strings:
  - Use template-based string formatting (.format() method)
  - Avoid nested f-strings completely
  - Build complex strings step by step rather than in single f-string expressions
  - Use YAML for any structured data, not JSON in f-strings

  Return as YAML format (NOT JSON due to f-string issues).